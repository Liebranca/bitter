#!/usr/bin/perl
# ---   *   ---   *   ---
# XORTILE
# A suspicion I needed
# confirmed
#
# TESTFILE
# jmp EOF for bits
#
# CONTRIBUTORS
# lyeb,

# ---   *   ---   *   ---
# deps

package main;

  use v5.36.0;
  use strict;
  use warnings;

  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';
  use Style;

  use lib $ENV{'ARPATH'}.'/THRONE/';
  use RPG::Dice;

# ---   *   ---   *   ---
# info

  our $AUTHOR='IBN-3DILA';

# ---   *   ---   *   ---
# ROM

  my $SIDE  = 16;
  my $SIZE  = $SIDE * $SIDE;
  my $LIMIT = $SIZE-1;
  my $TRY   = 1<<4;

# ---   *   ---   *   ---
# GBL

  my $Tab={};

# ---   *   ---   *   ---
# make block

sub chunk() {

  my @out   = ();
  my @bytes = map {
    RPG::Dice->roll("1d256")-1

  } 0..($SIZE*8)-1;

  while(@bytes) {

    my $x  = 0;
       $x |=

      ((shift @bytes) <<  0)
    | ((shift @bytes) <<  8)
    | ((shift @bytes) << 16)
    | ((shift @bytes) << 24)

    | ((shift @bytes) << 32)
    | ((shift @bytes) << 40)
    | ((shift @bytes) << 48)
    | ((shift @bytes) << 56)

    ;

    push @out,$x;

  };

  return @out;

};

# ---   *   ---   *   ---
# debug print block

sub prich(@ar) {

  for my $y(0..$SIDE-1) {

    my $i=1;
    for my $x(0..$SIDE-1) {
      my $pad="\n" x ($i<$SIDE-1 && ! ($i%2));
      printf "%016X $pad",$ar[$x+($y*$SIDE)];

      $i++;

    };

    print "\n";

  };

  print "\n";

};

# ---   *   ---   *   ---
# xor all elements of array

sub xortile(@ar) {

  my $x=0;
  map {$x^=$ARG} @ar;

  return $x;

};

# ---   *   ---   *   ---
# random integer of

sub ra_iof($ar) {

  my $limit = @$ar-1;
  my $idex  = RPG::Dice->roll("1d$limit")-1;

  return $idex;

};

# ---   *   ---   *   ---
# reorganize values randomly

sub ra_order(@ar) {

  my @out=();
  while(@ar) {

    my $idex=ra_iof(\@ar);

    push   @out,$ar[$idex];
    splice @ar,$idex,1;

  };

  return @out;

};

# ---   *   ---   *   ---
# get X for three chunks

sub xor_chunks($f=undef) {

  my @a=chunk();
  my @b=reverse @a;
  my @c=ra_order(@a);

  $f->(\@a,\@b,\@c) if defined $f;

  return (
    xortile(@a),
    xortile(@b),
    xortile(@c)

  );

};

# ---   *   ---   *   ---
# test 0 result

sub t0r($f=undef) {

  my $out=0;

  for my $i(0..$TRY-1) {

    my @r    = xor_chunks($f);
       $out += ($r[0] == $r[1] == $r[2]);

    $Tab->{$r[1]} //= 0;
    $Tab->{$r[1]}  += 1;

  };

  return $out==$TRY;

};

# ---   *   ---   *   ---
# test 1 result

sub t1r() {

  my $f=sub ($a,$b,$c) {
    for my $i(@$b) {

      my $idex=ra_iof($a);

      my $word=$a->[$idex];
      my $byte=$word&0xFF;

      $byte ^=  0x24;
      $word &=~ ((1 << 56)-1) << 8;
      $word |=  $byte;

      $a->[$idex]=$word;

    };

  };

  my $out=t0r($f);

  return ! $out;

};

# ---   *   ---   *   ---
# test 2 result

sub t2r() {

  my $out=0;

  map {

    $out=($ARG > $out)

      ? $ARG
      : $out
      ;

  } values %$Tab;

  return $out==1;

};

# ---   *   ---   *   ---
# crux

printf

  "%u%u%u\n",

  t0r(),
  t1r(),

  t2r(),

;

# ---   *   ---   *   ---
# ^the bit
#
#  given memory chunks (A,B,C),
#  we XOR every eight bytes in F
#  against an X nit 0, ret as out
#
#  under the following conditions:
#
#   * (A,B,C) are <= 2048 bytes
#   * A is randomly generated bytes
#   * B is {iv word order A}
#   * C is {ra word order A}
#
#  the tests (0,1) corroborate that:
#
#   * X ret F is equal for (A,B,C)
#   * changing a single byte generates
#     a different key, making the first
#     test fail
#
#  furthermore, test (2) suggests that:
#
#   * for blocks of this size,
#     collisions are impossible without
#     masking
#
#  ^from which i draw the conclusion that:
#
#   * for blocks of this size, F can
#     be used to recognize chunks
#     holding the same words but in
#     different combinations

# ---   *   ---   *   ---
1; # ret
