/*/*//*//*//*//*//*//*//*//*//*//*//*//*//*/*/
/*    LEX                                   *
*                                           *
*     -generates peso lexer                 *
*                                           */
// *   ---     ---     ---     ---     ---  *
/*    LIBRE SOFTWARE                        *
*                                           *
*     Licenced under GNU GPL3               *
*     be a bro and inherit                  *
*                                           */
// *   ---     ---     ---     ---     ---  *
/* CONTRIBUTORS                             *
*     lyeb,                                 *
*                                           */
/*/*//*//*//*//*//*//*//*//*//*//*//*//*//*/*/


//   ---     ---     ---     ---     ---

$:%lex;>

$:key type;>
	void

	char str
	short int long

	uchar ustr
	ushort uint ulong

	float double;

$:def type;>
	char   is int8_t \;
	short  is int16_t \;
	int    is int32_t \;
	long   is int64_t \;

	uchar  is uint8_t \;
	ushort is uint16_t \;
	uint   is uint32_t \;
	ulong  is uint64_t ;

$:key typeflag;>
	static extern inline mute bound parent const;

$:rule #typeflags;>
	\(( <typeflag> \)\\s+ \)* ;

$:key vfunct;>
	nihil stark;

$:key flow;>
	if eif else then jump;

$:def flow;>
	eif is else if \;
	then is { if ;

$:rule name;>
	\\w+ ;

$:rule #reserved;>
	\(\( <flow> | <vfunct> | <type> | <typeflag> \)) ;
//	^\(\(?! <flow> | <vfunct> | <type> | <typeflag> $ \).*)$ ;

$:rule namelist;>
	\(\\w+,*\)+ [\\s*|\\b] ;

$:rule space;>
	\\s+ ;

$:rule *;>
	\(\\s*\\*\\s+|\\s+\\*\\s*|\\s+\) ;

$:rule ptr;>
	\(\\s*\\*\\s+|\\s+\\*\\s*\) ;

$:rule :;>
	\\s*:\\s* ;

$:rule =;>
	\\s*=\\s* ;

$:rule op=;>
	\\s*\(\\+|\\-|\\*\\/)\\s*\\= ;

$:rule value;>
	\(0x[0-9A-F]*|0b[0-1]*|[0-9]*\\.?[0-9]*) ;

$:rule opsign;>
	\(\\~|\\[|\\]|\\(|\\)|\\{|\\}|\\-|\\+|\\*|\\/|\\%|\\||\\&|\\^|\\?|\\!|\\<|\\>\|\\=)* ;

$:rule #opvalue;>
	\( \\s* [ <opsign> | <value> | <name> ] \)+ ;

$:rule #arglist;>
	\( \( <type> \) <*> <namelist> \)+ ;

$:form vardecl;>
	<#typeflags> <vfunct> <ptr> <name> \;
	<#typeflags> <type> <*> <name> \;
	<#typeflags> <type> <*> <name> <=> <#opvalue> ;

$:trans vardecl;>
	0 (vfunct == nihil) #typeflags void \( ptr name \) \(void\) \;
	0 (vfunct == stark) #typeflags void \( ptr name \) \(void* buff\) \;
	1 (1 == 1) #typeflags type * name \;
	2 (1 == 1) #typeflags type * name = #opvalue \; ;

$:form assign;>
	<name> <=> <#opvalue> ;

$:trans assign;>
	0 (1 == 1) name = #opvalue \; ;

$:form inplace;>
	<name> \\s* \\+\\+ \;
	<name> \\s* \\-\\- \;
	<name> <op=> <#opvalue> ;

$:trans inplace;>
	0 (1==1) name ++ \;
	1 (1==1) name -- \;
	2 (1==1) name op= #opvalue \; ;

$:form fundecl;>
	<#typeflags> <vfunct> <space> <name> \;
	<#typeflags> <type> <*> <name> <:> void \;
	<#typeflags> <type> <*> <name> <:> <#arglist> ;

$:trans fundecl;>
	0 (vfunct == nihil) #typeflags void name \(void\) \;
	0 (vfunct == stark) #typeflags void name \(void* buff\) \;
	1 (1 == 1) #typeflags type * name \(void\) \;
	2 (1 == 1) #typeflags type * name \( #arglist \) \; ;

$:form flow;>
	<flow> \\s* <#opvalue> ;

$:trans flow;>
	0 (flow == else) flow \;
	0 (flow == jump) flow #opvalue \;
	0 (1 == 1) flow #opvalue \; ;

$:/lex;>

//   ---     ---     ---     ---     ---